}
EMPValues <- function(var.matrix, estimates,
number.samples, number.categories) {
# Makes probabilities used to make posterior probabilities and loglikelihoods
#
# Args:
#   var.matrix: A matrix of variables repeated, by column, for each category
#   estimates:  Estimates for distributions and proportions for each category
#   number.samples   : Number of data points
#   number.categories: Number of categories
# Returns:
#   A matrix of p values, a row for each data point, column for each category
# Generate matrices of means, sds
means <- matrix(rep(estimates[,1], number.samples),
ncol = number.categories, byrow = TRUE)
sds <- matrix(rep(estimates[,2], number.samples),
ncol = number.categories, byrow = TRUE)
# Generate the p values
p.vals <- dnorm(var.matrix, means, sds)
# Multiply by lambda
p.vals <- sweep(p.vals, 2, estimates[,3], '*')
return(p.vals)
}
EMPValuesFast <- function(var.matrix, estimates, number.categories) {
# (See EMPValues) A slightly faster but less easily read version of EMPValues
#
# Args:
#   var.matrix: A matrix of variables repeated, by column, for each category
#   estimates:  Estimates for distributions and proportions for each category
#   number.categories: Number of categories
# Returns:
#   A matrix of p values, a row for each data point, column for each category
return(matrix(unlist(lapply(1:number.categories, function(i)
dnorm(var.matrix[,i], estimates[i,1], estimates[i,2])*estimates[i,3])),
ncol = number.categories))
}
EMExpectation <- function(p.vals, number.categories) {
# Generates posterior probabilities of whether variables belong to categories
#
# Args:
#   p.vals: A matrix of p values generated by EMPvalues
#   number.categories: The number of possible categories
# Returns:
#   A matrix of posterior probabilities
#     rows = number of data points
#     columns = number of categories
# Divide by the sums of rows
row.sums <- matrix(rep(rowSums(p.vals),number.categories),
ncol = number.categories)
p.vals <- p.vals / row.sums
return(p.vals)
}
EMMaximization <- function(var.matrix, posterior,
number.samples, number.categories) {
# Generates new estimate from probabilities of previous estimate
#
# Args:
#   var.matrix: A matrix of variables repeated, by column, for each category
#   posterior :    Matrix of posterior probabilities from previous esimates
#   number.samples : Number of data points
#   number.categories : Number of categories
# Returns:
#   A table of estimates with rows for each category
#     and columns for mean, standard deviation, and lambda values
# Generate blank matrix for estimates
estimates <- as.data.frame(matrix(nrow = number.categories, ncol = 3))
colnames(estimates) <- c('mu', 'sigma', 'lambda')
# Generate weighted mean estimates
p.sums <- colSums(posterior)
pX.sums <- colSums(posterior * var.matrix)
estimates$mu <- pX.sums / p.sums
# Generate sigma estimates
pSpread.sums <- colSums(posterior *
((sweep(var.matrix, 2, estimates[,1], '-'))**2))
estimates$sigma <- sqrt(pSpread.sums / p.sums)
# Generate lambda estimates
estimates$lambda <- p.sums/number.samples
return(estimates)
}
EMLogLikelihood <- function(p.vals) {
# Calculates log-likelihood of data fitting estimated distributions
#
# Args:
#   p.vals: A matrix of p values generated by EMPvalues
# Returns:
#   The sum of log-likelihoods for the data
# Convert to log likelihoods and sum
p.vals <- log(rowSums(p.vals))
log.likelihood <- sum(p.vals)
return(log.likelihood)
}
MakeKnownExample <- function(means, sds, lambdas, n,
k, known.proportion, seed, fish = TRUE) {
# Generates random data from known distributions to test EM function
#
# Args:
#   means: Means for each normally distributed category
#   sds  : SDs for each normally dsitributed category
#   lambdas : Proportions of each category in population
#   n       : Number of samples to generate
#   k       : Number of categories
#   known.proportion : Proportion of samples with a known category
#   seed : Randomness seed
# Returns:
#   A data frame of known and unknown data fitting k categories
set.seed(seed)
data <- as.data.frame(matrix(nrow = n, ncol = 3))
known <- runif(n) < known.proportion
for (i in 1:n) {
category <- sample(1:k, 1, prob = lambdas)
data[i,2] <- rnorm(1, means[category], sds[category])
if (known[i]) {
data[i,3] <- category
}
}
if (fish) {
colnames(data) <- c("FishID", "Length", "Age")
}
return(data)
}
IsScalarNumber <- function(number, canBeNegative = TRUE) {
# Function to check is number is a scalar numeric value
# Args:
#   number = The variable to be checked
#   notNegative = Whether the variable can be a negative number
# Return:
#   A boolean as to whether the number passed the checks or not
if (is.complex(number))
{
return(FALSE)
}
if (!is.numeric(number))
{
return(FALSE)
}
if (length(number) > 1)
{
return(FALSE)
}
if (!canBeNegative & number < 0)
{
return(FALSE)
} else {
return(TRUE)
}
source('~/sd.R')
# I confirm that the attached is the work of our team, except where clearly
# indicated in the text
teamEM <- function(data, epsilon = 1e-08, maxit = 1000,
var.col = 2, cat.col = 3, fish = TRUE) {
# Uses Expectation Maximisation to estimate fish lengths for each age
#
# Args:
#   data:    A dataframe containing a known 'variable' and unknown 'category'
#   epsilon: A tolerance value for log likelihood differences
#   maxit:   Maximum number of iterations of the algorithm
#   var.col: The column index of the variable
#   cat.col: The column index of the category
#   fish   : Whether or not the data is the default 'fish lengths' file
# Returns:
#   A named list containing the following:
#   estimates: A dataframe of estimate means, sds and lambda for each age
#   inits:     A dataframe of initial estimates
#   converged: Boolean indicating whether or not algorithm converged
#   posterior: A dataframe of posterior probabilities
#   likelihood: Vector of log-likelihood values, one for each iteration
#Input checks:
# 1. If fish data must have a numeric variable column named 'length'-----------
#   and a column named 'age'
if (!is.data.frame(data)) {
stop("Invalid argument: data must be a dataframe")
}
if (fish) {
if (!('Length' %in% colnames(data)) | !('Age' %in% colnames(data))) {
stop("Invalid argument: data must have 'Length' and 'Age' column")
}
var.col <- which(colnames(data) == 'Length')
cat.col <- which(colnames(data) == 'Age')
}
# Prepping table for analysis
colnames(data)[var.col] <- 'variable'
colnames(data)[cat.col] <- 'category'
# 2. Epsilon and maxit must be positive, scalar, numeric values----------
if (!IsScalarNumber(epsilon, FALSE) | !IsScalarNumber(maxit, FALSE)) {
stop("Invalid arguments")
}
#   var.col and cat.col must be positive, scalar, numeric values
#   and be a column within the dataframe
if (!IsScalarNumber(var.col, FALSE) | !IsScalarNumber(cat.col, FALSE)) {
stop("Invalid arguments")
}
else if (var.col > ncol(data) | cat.col > ncol(data)) {
stop("var.col and cat.col must lie within the dataframe")
}
# 3.  Whether variables are numeric  ------------------------
if(any(!is.numeric(data$variable))){
stop("invalid variable value, must be numeric")
}
#Prepping table for analysis-------
#handel data with non-numeric category
categories.name<-unique(na.omit(data$category))
data$category[!is.na(data$category)]<-as.numeric(as.factor(data$category[!is.na(data$category)]))
categories <- unique(data$category[!is.na(data$category)])
unknown.data <- subset(data,is.na(data$category))
known.data <- subset(data,!is.na(data$category))
# Generates reused variables
number.categories <- length(categories)
number.samples <- nrow(data)
# Error handling:  Each category must have at least 2 known data entries----
for (i in number.categories) {
if (length(known.data$variable[known.data$category == categories[i]])< 2) {
stop("Error: Each category must have at least 2 known samples")
}
}
# Initialization---------------
var.matrix <- matrix(rep(data$variable, number.categories),
ncol = number.categories)
inits <- EMInitialization(data, categories, number.samples,
number.categories)
# Stat iterations---------------
estimates <- inits
p.vals <- EMPValuesFast(var.matrix, estimates, number.categories)
log.likelihood <- EMLogLikelihood(p.vals)
likelihoods <- numeric(maxit)
converged <- FALSE
for (i in 1:maxit) {
# Expectation
posterior <- EMExpectation(p.vals, number.categories)
# Maximization
estimates <- EMMaximization(var.matrix, posterior, number.samples,
number.categories)
# Likelihood Evaluation
prev.log.likelihood <- log.likelihood
p.vals <- EMPValuesFast(var.matrix, estimates, number.categories)
log.likelihood <- EMLogLikelihood(p.vals)
likelihoods[i] <- log.likelihood
if(abs(prev.log.likelihood - log.likelihood) < epsilon){
converged <- TRUE
break
}
}
# Generate posterior probabilities for final estimates
posterior <- as.data.frame(EMExpectation(p.vals, number.categories))
# Prepare return values for readability and ease of use---------------
if (fish) {
rownames(estimates) <- c("Age1", "Age2", "Age3")
rownames(inits) <- c("Age1", "Age2", "Age3")
} else {
rownames(estimates) <- categories
rownames(inits) <- categories
}
likelihood <- likelihoods[likelihoods != 0]
return.list <- list(estimates, inits, converged, posterior, likelihood)
names(return.list) <-
c('estimates', 'inits', 'converged', 'posterior', 'likelihood')
# Return
return(return.list)
}
EMInitialization <- function(data, categories, number.samples,
number.categories) {
# Generates initial estimates for categories from incomplete data
#
# Args:
#   data: A dataframe containing a known 'variable' and unknown 'category'
# Returns:
#   A table of estimates with rows for each category
#     and columns for mean, standard deviation, and lambda values
# Isolate known data
known.data <- data[!is.na(data$category),]
# Generate original guesses of mean and sds, and pvals for each datapoint
means <- numeric(number.categories)
sds <- numeric(number.categories)
p.vals <- matrix(nrow = number.samples, ncol = number.categories)
# For loop is faster than tapply here
for (i in 1:number.categories) {
means[i] <- mean(known.data$variable[known.data$category == categories[i]])
sds[i] <- sd(known.data$variable[known.data$category == categories[i]])
p.vals[,i] <- dnorm(data$variable, means[i], sds[i])
}
# Assign label category guesses based on p vals
data <- transform(data, category =
ifelse((is.na(category)),
as.factor(max.col(p.vals)), category))
# Generate estimates based on filled dataset
estimates <- as.data.frame(matrix(nrow = number.categories, ncol = 3))
colnames(estimates) <- c('mu', 'sigma', 'lambda')
for (i in 1:number.categories) {
estimates$mu[i] <- mean(data$variable[data$category == categories[i]])
estimates$sigma[i] <- sd(data$variable[data$category == categories[i]])
estimates$lambda[i] <-
length(data$variable[data$category == categories[i]])/number.samples
}
# Return the estimates
return(estimates)
}
EMPValues <- function(var.matrix, estimates,
number.samples, number.categories) {
# Makes probabilities used to make posterior probabilities and loglikelihoods
#
# Args:
#   var.matrix: A matrix of variables repeated, by column, for each category
#   estimates:  Estimates for distributions and proportions for each category
#   number.samples   : Number of data points
#   number.categories: Number of categories
# Returns:
#   A matrix of p values, a row for each data point, column for each category
# Generate matrices of means, sds
means <- matrix(rep(estimates[,1], number.samples),
ncol = number.categories, byrow = TRUE)
sds <- matrix(rep(estimates[,2], number.samples),
ncol = number.categories, byrow = TRUE)
# Generate the p values
p.vals <- dnorm(var.matrix, means, sds)
# Multiply by lambda
p.vals <- sweep(p.vals, 2, estimates[,3], '*')
return(p.vals)
}
EMPValuesFast <- function(var.matrix, estimates, number.categories) {
# (See EMPValues) A slightly faster but less easily read version of EMPValues
#
# Args:
#   var.matrix: A matrix of variables repeated, by column, for each category
#   estimates:  Estimates for distributions and proportions for each category
#   number.categories: Number of categories
# Returns:
#   A matrix of p values, a row for each data point, column for each category
return(matrix(unlist(lapply(1:number.categories, function(i)
dnorm(var.matrix[,i], estimates[i,1], estimates[i,2])*estimates[i,3])),
ncol = number.categories))
}
EMExpectation <- function(p.vals, number.categories) {
# Generates posterior probabilities of whether variables belong to categories
#
# Args:
#   p.vals: A matrix of p values generated by EMPvalues
#   number.categories: The number of possible categories
# Returns:
#   A matrix of posterior probabilities
#     rows = number of data points
#     columns = number of categories
# Divide by the sums of rows
row.sums <- matrix(rep(rowSums(p.vals),number.categories),
ncol = number.categories)
p.vals <- p.vals / row.sums
return(p.vals)
}
EMMaximization <- function(var.matrix, posterior,
number.samples, number.categories) {
# Generates new estimate from probabilities of previous estimate
#
# Args:
#   var.matrix: A matrix of variables repeated, by column, for each category
#   posterior :    Matrix of posterior probabilities from previous esimates
#   number.samples : Number of data points
#   number.categories : Number of categories
# Returns:
#   A table of estimates with rows for each category
#     and columns for mean, standard deviation, and lambda values
# Generate blank matrix for estimates
estimates <- as.data.frame(matrix(nrow = number.categories, ncol = 3))
colnames(estimates) <- c('mu', 'sigma', 'lambda')
# Generate weighted mean estimates
p.sums <- colSums(posterior)
pX.sums <- colSums(posterior * var.matrix)
estimates$mu <- pX.sums / p.sums
# Generate sigma estimates
pSpread.sums <- colSums(posterior *
((sweep(var.matrix, 2, estimates[,1], '-'))**2))
estimates$sigma <- sqrt(pSpread.sums / p.sums)
# Generate lambda estimates
estimates$lambda <- p.sums/number.samples
return(estimates)
}
EMLogLikelihood <- function(p.vals) {
# Calculates log-likelihood of data fitting estimated distributions
#
# Args:
#   p.vals: A matrix of p values generated by EMPvalues
# Returns:
#   The sum of log-likelihoods for the data
# Convert to log likelihoods and sum
p.vals <- log(rowSums(p.vals))
log.likelihood <- sum(p.vals)
return(log.likelihood)
}
MakeKnownExample <- function(means, sds, lambdas, n,
k, known.proportion, seed, fish = TRUE) {
# Generates random data from known distributions to test EM function
#
# Args:
#   means: Means for each normally distributed category
#   sds  : SDs for each normally dsitributed category
#   lambdas : Proportions of each category in population
#   n       : Number of samples to generate
#   k       : Number of categories
#   known.proportion : Proportion of samples with a known category
#   seed : Randomness seed
# Returns:
#   A data frame of known and unknown data fitting k categories
set.seed(seed)
data <- as.data.frame(matrix(nrow = n, ncol = 3))
known <- runif(n) < known.proportion
for (i in 1:n) {
category <- sample(1:k, 1, prob = lambdas)
data[i,2] <- rnorm(1, means[category], sds[category])
if (known[i]) {
data[i,3] <- category
}
}
if (fish) {
colnames(data) <- c("FishID", "Length", "Age")
}
return(data)
}
IsScalarNumber <- function(number, canBeNegative = TRUE) {
# Function to check is number is a scalar numeric value
# Args:
#   number = The variable to be checked
#   notNegative = Whether the variable can be a negative number
# Return:
#   A boolean as to whether the number passed the checks or not
if (is.complex(number))
{
return(FALSE)
}
if (!is.numeric(number))
{
return(FALSE)
}
if (length(number) > 1)
{
return(FALSE)
}
if (!canBeNegative & number < 0)
{
return(FALSE)
} else {
return(TRUE)
}
}
}
IsScalarNumber <- function(number, canBeNegative = TRUE) {
# Function to check is number is a scalar numeric value
# Args:
#   number = The variable to be checked
#   notNegative = Whether the variable can be a negative number
# Return:
#   A boolean as to whether the number passed the checks or not
if (is.complex(number))
{
return(FALSE)
}
if (!is.numeric(number))
{
return(FALSE)
}
if (length(number) > 1)
{
return(FALSE)
}
if (!canBeNegative & number < 0)
{
return(FALSE)
} else {
return(TRUE)
}
}
source('~/sd.R')
mod=teamEM(x)
View(mod)
mod=teamEM(x)
View(mod)
emod=normalmixEM(x$Length)
emod=normalmixEM(x$Length,k=4)
emod=normalmixEM(x$Length,k=4,mu=mod$inits$mu,sigma = mod$inits$sigma,lambda = mod$inits$lambda)
View(mod)
View(emod)
mod=teamEM(test_set)
mod=teamEM(test_set,fish = FALSE,var.col = 2,cat.col = 1)
View(mod)
View(mod)
emod=normalmixEM(test_set$Al,k=4,mu=mod$inits$mu,sigma = mod$inits$sigma,lambda = mod$inits$lambda)
View(emod)
EMExpectation()
EMExpectation
setwd("~/playground/acpack/mypackage/sohaRd")
library(devtools)
library(roxygen2)
document("sohaRd")
setwd("~/playground/acpack/mypackage")
document("sohaRd")
document("sohaRd")
build("sohaRd")
package.skeleton(name = "sohaRd",list = c("clean.table","fun2"))
package.skeleton(name = "sohaRd", list = c("clean.table","fun2"))
package.skeleton(name = "sohaRd", list = c("clean.table","fun2"))
document("sohaRd")
document("sohaRd")
build("sohaRd")
View(EMLogLikelihood)
document("sohaRd")
build("sohaRd")
package.skeleton(name = "sohaRd",list = c("clean.table","fun2"))
document("sohaRd")
document("sohaRd")
document("sohaRd")
setwd("~/playground/acpack/mypackage/sohaRd")
document("sohaRd")
setwd("~/playground/acpack/mypackage/sohaRd")
setwd("~/playground/acpack/mypackage")
package.skeleton("sohard")
package.skeleton("sohard2")
